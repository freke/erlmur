You are an expert software architect and project analysis assistant. Your task
is to analyze the current project directory recursively and generate a
comprehensive `GEMINI.md` file. This file will serve as a foundational
context guide for any future AI model, like yourself, that interacts with this
project. The goal is to ensure that future AI-generated code, analysis, and
modifications are consistent with the project's established standards and
architecture.

**Core Instructions:**

*   **Scan and Analyze:** Recursively scan the entire file and folder
    structure starting from the provided root directory.
*   **Identify Key Artifacts:** Pay close attention to build scripts,
    configuration files (`rebar.config`, `package.json`, etc.), READMEs,
    folder hierarchy, documentation files, and source code.
*   **Incorporate Contribution & Development Guidelines:** Search for and parse
    any files related to development, testing, or contributions (e.g.,
    `CONTRIBUTING.md`, `DEVELOPMENT.md`, `TESTING.md`). The instructions
    within these guides are critical and must be summarized and included in the
    final output.
*   **Infer and Document Standards:** Do not just list files. You must infer
    the project's implicit and explicit standards from its structure and code.
    This includes coding style, architectural patterns, and workflows.
    Clearly state when a standard is inferred versus when it is explicitly
    documented.

**Output Format:**

*   Generate a single, well-formatted Markdown file named `GEMINI.md`.
*   Populate each section of the template below based on your analysis.
*   If you cannot confidently determine the information for a section, state
    that it is "Inferred" and note your confidence level, or write
    "Information not available."
*   **Do not remove sections.** If a section is not applicable (e.g., no
    database), state "Not applicable." to maintain a consistent structure.

---

**FILE STRUCTURE TO GENERATE:**

# GEMINI.MD: AI Collaboration Guide

This document provides essential context for AI models interacting with this
project. Adhering to these guidelines will ensure consistency and maintain code
quality.

## 1. Project Overview & Purpose

*   **Primary Goal:** [Analyze the README.md, documentation, and folder names
    to infer and summarize the project's main purpose and what it's designed
    to do. Example: "This is a REST API backend for a social media
    application."]
*   **Business Domain:** [Describe the domain the project operates in, e.g.,
    "E-commerce," "Fintech," "Real-time Voice Communication."]
*   **Project Status:** [Infer the current state of the project. E.g.,
    "Early-stage development," "Actively maintained," "Mature/Stable," "Proof
    of concept."]

## 2. Core Technologies & Stack

*   **Languages:** [List primary programming languages, including versions if
    specified.]
*   **Frameworks & Runtimes:** [List major frameworks (e.g., OTP, Ranch) and
    the runtime environment (e.g., Erlang/OTP 25).]
*   **Databases:** [Identify the database systems used (e.g., Mnesia,
    PostgreSQL).]
*   **Key Libraries/Dependencies:** [List the most critical libraries that
    define the project's functionality (e.g., `ranch`, `protobuffs`).]
*   **Package Manager(s):** [Identify the package managers used (e.g.,
    `rebar3`, `hex`).]

## 3. Architectural Patterns

*   **Overall Architecture:** [Infer the high-level architecture. State your
    reasoning. Examples: "Monolithic Application following standard OTP design
    principles," "Microservices Architecture," "Model-View-Controller (MVC)."]
*   **Directory Structure Philosophy:** [Explain the purpose of the main
    directories. Example:
  *   `/src`: Contains all primary Erlang source code.
  *   `/include`: Contains header files (`.hrl`), such as record
        definitions.
  *   `/test`: Contains all unit and integration tests.
  *   `/docs`: Holds project documentation.]
*   **Language-Specific Best Practices:** [Describe best practices recommended
    for the current languages used. Example: "Follows standard Erlang/OTP
    conventions for process supervision and state management. Functions should
    be pure where possible."]

## 4. Coding Conventions & Style Guide

*   **Formatting:** [Infer from source files and any linter configs (e.g.,
    `.formatter.exs`, `erlfmt.config`). Note any standard style guides
    mentioned. Example: "The project uses `rebar3 fmt` for automated code
    formatting."]
*   **Naming Conventions:** [Analyze variable, function, class, and file names.
    Example:
  *   `modules`, `functions`: `lowercase_with_underscores` (e.g.,
        `my_module`, `my_function`)
  *   `variables`: `PascalCase` (e.g., `MyVariable`)
  *   `records`: `lowercase` (e.g., `#my_record{}`)]
*   **API Design:** [If applicable, describe the API style. Example: "Internal
    API is function-based. External communication uses Google Protocol Buffers
    defined in the `/proto` directory."]
*   **Error Handling:** [Observe common error handling patterns. Example:
    "Follows the 'let it crash' philosophy common in OTP. Supervisors are
    responsible for restarting failed processes. Functions return tagged
    tuples like `{ok, Value}` or `{error, Reason}`."]

## 5. Key Files & Entrypoints

*   **Main Entrypoint(s):** [Identify the starting point of the application,
    typically the main application callback module, e.g., `erlmur_app.erl`.]
*   **Configuration:** [List the primary files for environment and application
    configuration, e.g., `rebar.config`, `sys.config`.]
*   **CI/CD Pipeline:** [Identify the continuous integration configuration
    file, e.g., `.github/workflows/main.yml`, `justfile` if used for CI
    steps.]

## 6. Development & Testing Workflow

*   **Local Development Environment:** [Summarize the standard procedure for
    setting up and running the project locally. Note key tools or commands
    from files like `README.md` or `justfile`.]
*   **Testing:** [Describe how tests are run. Note any specific commands,
    frameworks, or conventions. Example: "Run the full test suite via `just
    test`. New code requires corresponding unit, common test, and
    property-based tests."]
*   **CI/CD Process:** [Briefly explain what happens when code is committed or a
    PR is created, based on the CI/CD pipeline files. If none, state that.]

## 7. Specific Instructions for AI Collaboration

*   **Contribution Guidelines:** [Summarize key instructions from
    `CONTRIBUTING.md` or similar files. Example: "All pull requests must be
    submitted against the `main` branch and require a code review. All
    changes must adhere to the design documents in `/docs`."]
*   **Code Reviews:** [When asked to perform a code review,
		analyze both the source code and any corresponding documentation (e.g., in the `/docs` directory).
		If you find a discrepancy, assume the source code is the source of truth and the documentation is outdated.
		The documentation should provide a high-level conceptual overview, not a detailed, line-by-line explanation of the code. 
		If documentation for a feature is missing entirely, notify the user.]
*   **Infrastructure (IaC):** [Note if an Infrastructure as Code directory
    exists. Add a warning if applicable. Example: "Not applicable."]
*   **Security:** [Add a general reminder about security best practices.
    Example: "Be mindful of security. Do not hardcode secrets or keys.
    Sanitize all external input."]
*   **Dependencies:** [Explain the process for adding new dependencies. Example:
    "To add a new dependency, edit the `deps` section in `rebar.config` and
    run `rebar3 upgrade`."]
*   **Commit Messages:** [If a `.git` directory exists, analyze the commit
    history for patterns. Example: "Commit messages should be concise and
    written in the imperative mood (e.g., `feat: Add user
    authentication`)."]
